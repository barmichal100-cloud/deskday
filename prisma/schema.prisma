datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

enum UserRole {
  RENTER
  OWNER
  ADMIN
}

enum Locale {
  EN
  HE
}

enum Currency {
  ILS
  USD
  EUR
}

enum BookingStatus {
  PENDING    // Temporary state while Stripe checkout is in progress
  CONFIRMED  // Payment successful, booking is active
  CANCELLED
  REFUNDED
}

enum BlockReason {
  OWNER_BLOCKED
  BOOKED
}

enum PayoutStatus {
  PENDING
  SCHEDULED
  PAID
  FAILED
  DISPUTED
}

enum DisputeStatus {
  NONE
  FILED
  UNDER_REVIEW
  RESOLVED
}

model User {
  id                 String   @id @default(cuid())
  email              String   @unique
  passwordHash       String
  name               String?
  companyName        String?
  phone              String?
  role               UserRole @default(RENTER)
  preferredLocale    Locale   @default(EN)
  preferredCurrency  Currency @default(ILS)
  stripeCustomerId   String?

  // Stripe Connect fields for owners
  stripeConnectAccountId    String?  @unique
  stripeOnboardingComplete  Boolean  @default(false)
  stripeDetailsSubmitted    Boolean  @default(false)
  stripeChargesEnabled      Boolean  @default(false)
  stripePayoutsEnabled      Boolean  @default(false)

  desks                    Desk[]
  bookings                 Booking[] @relation("RenterBookings")
  payouts                  Payout[]
  reviews                  Review[]
  favorites                Favorite[]
  notificationPreferences  NotificationPreferences?
  sentMessages             Message[] @relation("SentMessages")
  conversationParticipants ConversationParticipant[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Desk {
  id      String @id @default(cuid())
  owner   User   @relation(fields: [ownerId], references: [id])
  ownerId String

  title_en       String
  title_he       String?
  description_en String
  description_he String?
  houseRules_en  String?
  houseRules_he  String?

  address String
  city    String
  country String
  lat     Float?
  lng     Float?

  pricePerDay Int
  currency    String

  amenities Json
  isActive  Boolean @default(true)

  photos         DeskPhoto[]
  bookings       Booking[]
  blockedDates   DeskBlockedDate[]
  availableDates DeskAvailableDate[]
  reviews        Review[]
  favorites      Favorite[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model DeskPhoto {
  id        String   @id @default(cuid())
  desk      Desk     @relation(fields: [deskId], references: [id])
  deskId    String
  url       String
  thumbnailUrl String?
  order     Int      @default(0)
  createdAt DateTime @default(now())
}

model DeskBlockedDate {
  id        String      @id @default(cuid())
  desk      Desk        @relation(fields: [deskId], references: [id])
  deskId    String
  date      DateTime
  reason    BlockReason
  createdAt DateTime    @default(now())
}

model DeskAvailableDate {
  id        String   @id @default(cuid())
  desk      Desk     @relation(fields: [deskId], references: [id], onDelete: Cascade)
  deskId    String
  date      DateTime @db.Date
  createdAt DateTime @default(now())

  @@unique([deskId, date])
}

model Booking {
  id     String @id @default(cuid())
  desk   Desk   @relation(fields: [deskId], references: [id])
  deskId String

  renter   User   @relation("RenterBookings", fields: [renterId], references: [id])
  renterId String

  startDate DateTime
  endDate   DateTime
  bookedDates Json? // Array of date strings in YYYY-MM-DD format

  totalAmount     Int
  deskOwnerAmount Int
  platformFee     Int
  currency        String

  status BookingStatus @default(PENDING)

  stripePaymentIntentId   String?
  stripeCheckoutSessionId String?

  // Payout and dispute tracking
  payoutStatus          PayoutStatus   @default(PENDING)
  payoutScheduledDate   DateTime?
  payoutCompletedDate   DateTime?
  disputeStatus         DisputeStatus  @default(NONE)
  disputeReason         String?
  disputeFiledAt        DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  payout  Payout?
  reviews Review[]
}

model Payout {
  id      String @id @default(cuid())
  owner   User   @relation(fields: [ownerId], references: [id])
  ownerId String

  // One payout per booking â€“ bookingId must be unique
  booking   Booking @relation(fields: [bookingId], references: [id])
  bookingId String  @unique

  amount   Int
  currency String
  status   PayoutStatus @default(PENDING)

  stripeTransferId String?
  payoutDate       DateTime?
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt
}

model Review {
  id        String  @id @default(cuid())
  booking   Booking @relation(fields: [bookingId], references: [id])
  bookingId String

  author   User   @relation(fields: [authorId], references: [id])
  authorId String

  desk   Desk   @relation(fields: [deskId], references: [id])
  deskId String

  rating    Int
  comment   String?
  createdAt DateTime @default(now())
}

model Favorite {
  id        String   @id @default(cuid())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    String
  desk      Desk     @relation(fields: [deskId], references: [id], onDelete: Cascade)
  deskId    String
  createdAt DateTime @default(now())

  @@unique([userId, deskId])
}

model SystemLog {
  id        String   @id @default(cuid())
  userId    String?
  type      String
  data      Json?
  createdAt DateTime @default(now())
}

model NotificationPreferences {
  id     String @id @default(cuid())
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId String @unique

  // Booking notifications
  bookingConfirmationEmail Boolean @default(true)
  bookingConfirmationPush  Boolean @default(true)
  bookingConfirmationSms   Boolean @default(false)

  bookingReminderEmail Boolean @default(true)
  bookingReminderPush  Boolean @default(true)
  bookingReminderSms   Boolean @default(false)

  bookingCancellationEmail Boolean @default(true)
  bookingCancellationPush  Boolean @default(true)
  bookingCancellationSms   Boolean @default(false)

  // Owner notifications
  newBookingRequestEmail Boolean @default(true)
  newBookingRequestPush  Boolean @default(true)
  newBookingRequestSms   Boolean @default(false)

  paymentReceivedEmail Boolean @default(true)
  paymentReceivedPush  Boolean @default(false)
  paymentReceivedSms   Boolean @default(false)

  reviewReceivedEmail Boolean @default(true)
  reviewReceivedPush  Boolean @default(true)
  reviewReceivedSms   Boolean @default(false)

  // General notifications
  accountActivityEmail Boolean @default(true)
  accountActivityPush  Boolean @default(false)
  accountActivitySms   Boolean @default(false)

  promotionsAndTipsEmail Boolean @default(false)
  promotionsAndTipsPush  Boolean @default(false)
  promotionsAndTipsSms   Boolean @default(false)

  newsAndUpdatesEmail Boolean @default(false)
  newsAndUpdatesPush  Boolean @default(false)
  newsAndUpdatesSms   Boolean @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Conversation {
  id               String   @id @default(cuid())
  bookingId        String?  // Optional: link conversation to a booking
  deskId           String?  // Optional: link conversation to a desk

  participants     ConversationParticipant[]
  messages         Message[]

  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt
}

model ConversationParticipant {
  id             String   @id @default(cuid())
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  conversationId String
  user           User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId         String

  lastReadAt     DateTime? // Track when user last read messages

  createdAt      DateTime @default(now())

  @@unique([conversationId, userId])
}

model Message {
  id             String       @id @default(cuid())
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  conversationId String
  sender         User         @relation("SentMessages", fields: [senderId], references: [id], onDelete: Cascade)
  senderId       String

  content        String
  isRead         Boolean      @default(false)

  createdAt      DateTime     @default(now())
}
